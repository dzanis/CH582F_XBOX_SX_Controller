# CH582 в роли хоста для геймпада Xbox Series X

Этот проект позволяет микроконтроллеру CH582 выступать в качестве хоста (BLE Central) и подключаться к геймпаду Microsoft Xbox Series X.

Проект управляет процессом BLE-сканирования, сопряжения (Bonding), MAC-адрес геймпада в EEPROM и приемом данных о положении стиков и кнопок (HID Input Reports).

## Индикация светодиода (LED)

Светодиод на плате CH582 используется для индикации текущего состояния:

* **Медленное мигание** (1 раз в секунду):
    * **Значение:** Идет сканирование. CH582 ищет геймпад в эфире.
    * **Действие:** Нажмите и удерживайте кнопку **"Connect"**

* **Быстрое мигание** (несколько раз в секунду):
    * **Значение:** Устройство найдено, идет процесс сопряжения (Pairing/Bonding) и настройки.
    * **Действие:** Нажмите и удерживайте кнопку **"Connect"** пока мигание не прекратится

* **Горит постоянно:**
    * **Значение:** Геймпад успешно подключен, канал зашифрован, данные поступают.
    * **Действие:** Готово к работе!

---

## Как подключить геймпад (подробно)

### Первое подключение (Сопряжение и Сохранение)

Цель этого этапа — "познакомить" CH582 и геймпад, а также сохранить MAC-адрес геймпада в EEPROM.

1.  Включите CH582. Светодиод (LED) должен начать **медленно мигать** (режим сканирования).
2.  Возьмите геймпад Xbox. Нажмите и удерживайте кнопку **"Connect"** (маленькая круглая кнопка сверху геймпада), пока кнопка "Xbox" не начнет быстро мигать.
3.  CH582 обнаружит геймпад. LED на CH582 переключится на **быстрое мигание** (идет сопряжение).
4.  Через несколько секунд в логе (UART) появится сообщение `Bond save success`. MAC-адрес геймпада сохранен.
5.  **ВАЖНО:** На этом этапе нотификации, скорее всего, **не** пойдут. LED на CH582 продолжит быстро мигать, а геймпад продолжит поиск (кнопка "Xbox" будет моргать). *Это нормально.*
6. Продолжить приём данных из контроллёра можно повторным долгим нажатием на **"Connect"** или выключением XBOX контроллера


### Последующие подключения

После того как вы один раз выполнили **Первое подключение** , сопряжение сохранено.

Теперь достаточно просто включить геймпад кнопкой "Xbox". Он автоматически найдет CH582, и LED на обоих устройствах сразу загорится **постоянно**, пропуская все этапы настройки.

#  Руководство как использовать `xbox_sx_controller`

## 1\. Общая логика

1.  **Регистрация:** В `main.c` мы регистрируем нашу функцию (`handle_xbox_data`) в модуле `central.c`.
2.  **Callback:** Модуль `central.c` автоматически вызывает `handle_xbox_data` каждый раз, когда от геймпада приходит новый пакет данных (нотификация).
3.  **Парсинг:** Внутри `handle_xbox_data` мы используем функции из `xbox_sx_controller` (например, `Xbox_Update_State`) для обновления нашей глобальной структуры `xc_state`.
4.  **Чтение:** Вся остальная логика (например, вывод в лог) читает данные из этой готовой структуры `xc_state`.

## 2\. Пример использования (из `main.c`)

Вот полный пример, показывающий, как интегрировать библиотеку.

### 2.1. Подключение и инициализация (`main.c`)

В `main()` мы должны инициализировать `central.c` и, самое главное, зарегистрировать нашу функцию-обработчик `handle_xbox_data` с помощью `Central_RegisterGamepadInputCallback`.

```c

#include "xbox_sx_controller.h" // Наша библиотека парсера


// Глобальная переменная для хранения состояния геймпада
static XboxControllerState_t xc_state = {0}; 

// Наша функция-обработчик
void handle_xbox_data(uint8_t* ble_data, uint16_t data_len);

int main(void)
{
    ...
    // !!! САМЫЙ ВАЖНЫЙ ШАГ !!!
    // Регистрируем нашу функцию 'handle_xbox_data' в central.c
    Central_RegisterGamepadInputCallback(handle_xbox_data);
    ...
}
```

### 2.2. Обработка данных (Callback)

Эта функция вызывается автоматически из `central.c`. Здесь мы используем библиотеку для парсинга данных.

```c
void handle_xbox_data(uint8_t* ble_data, uint16_t data_len) 
{
    // Опционально: Проверка на дубликаты данных,
    // чтобы не обрабатывать один и тот же пакет
    // ПРИМЕЧАНИЕ: tmos_memcmp возвращает 1 при совпадении
    if (tmos_memcmp(&xc_state, ble_data, XBOX_CONTROLLER_TOTAL_PACKAGE_SIZE))
    {
        return; // Пропуск дублирующего пакета
    }

    // Вызываем функцию парсера
    uint8_t error = Xbox_Update_State(&xc_state, ble_data, data_len);

    // Используем данные
    if (error == 0) // Если парсинг прошел успешно
    {
        //  Вывод в лог (пример)
        Xbox_Print_State(&xc_state);

        // Чтение кнопок (пример)
        if (Xbox_Is_Pressed(&xc_state, SHARE))
        {
            PRINT("Share pressed!\n");
        }
        
    }
    else
    {
        PRINT("Error parsing Xbox data: %u\n", error);
    }
}
```

### 2.3. Чтение состояния (Как пользоваться `xc_state`)

После того как `Xbox_Update_State` отработала, вы можете в любой момент получить доступ к актуальному состоянию геймпада из глобальной переменной `xc_state`.

Состояния кнопок A, B, X, Y, и View, Menu, Xbox, LS, RS можно получить  проверкой методом `Xbox_Is_Pressed`

```c
// Пример проверки кнопки A
if (Xbox_Is_Pressed(&xc_state, A)) {
    // Кнопка A нажата
}

// или просто 

if (xc_state.buttonsABXY & MASK_A) {
    // Кнопка A нажата
}

// Пример чтения Левого Стика X
uint16_t lx = xc_state.leftX;
if (lx < 30000) {
    // Стик отклонен влево
}

// Пример чтения D-Pad
if (xc_state.dpad == DPAD_UP) { // 1 = Вверх
    // Нажато "Вверх"
}
```